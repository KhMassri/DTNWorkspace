/**
 * 
 */
package routing;




import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

import movement.MovementModel;

import core.Connection;
import core.DTNHost;
import core.DTNSim;
import core.Message;
import core.Settings;

/**
 * @author khalil
 *
 */
public class FadSink extends ActiveRouter {

	private static Set<String> sinkedMessages=new HashSet<String>();
	private static List<Set<String>> codeWords= new ArrayList<Set<String>>();

	
	
	/**
	 * @param s
	 */
	public FadSink(Settings s) {
		super(s);
	}

	protected FadSink(FadSink r) {
		super(r);
	}

	static {
		DTNSim.registerForReset(FadSink.class.getCanonicalName());				
		reset();
	}
	
	public void changedConnection(Connection con) {
		return;
	}
			
	
	@Override
	public void update() {
		super.update();
		if (isTransferring() || !canStartTransfer()) {
			return; // transferring, don't try other connections yet
		
		}	
	}
		
	public Message messageTransferred(String id, DTNHost from){
		String[] ids = id.split("&");
		if(ids.length>1)
		{
			if(sinkedMessages.contains(ids[0]) && !sinkedMessages.contains(ids[1]))
			{
				Message m = super.messageTransferred(ids[1], from);
				sinkedMessages.add(ids[1]);
				return m;
				
			}
			else if(sinkedMessages.contains(ids[1]) && !sinkedMessages.contains(ids[0]))
			{
				Message m = super.messageTransferred(ids[0], from);
				sinkedMessages.add(ids[0]);
				return m;
				
			}
			
			else
			{
				Set<String> code = new HashSet<String>();
				Collections.addAll(code, ids);
				codeWords.add(code);
				return null;
				
			}
			
			
		}
		else
		{
			Message m = super.messageTransferred(id, from);
			sinkedMessages.add(m.getId());
			return m;	
		}
	}
	
	protected int checkReceiving(Message m) {
		String[] ids = m.getId().split("&");
		
		
		if(ids.length>1)
		{
			if(sinkedMessages.contains(ids[0]) && sinkedMessages.contains(ids[1]))
			{
				
				return DENIED_OLD;
				
			}
			else if(sinkedMessages.contains(ids[1]) && !sinkedMessages.contains(ids[0]))
			{
				m.setID(ids[0]);
				int result = super.checkReceiving(m);
				
				if (result == RCV_OK)
					if (FadSink.insert(m))
						return result;
					else
						return DENIED_OLD;
				
			}
			else if(sinkedMessages.contains(ids[0]) && !sinkedMessages.contains(ids[1]))
			{
				m.setID(ids[1]);
				int result = super.checkReceiving(m);
				
				if (result == RCV_OK)
					if (FadSink.insert(m))
						return result;
					else
						return DENIED_OLD;
				
			}
			
			else
			{
				Set<String> code = new HashSet<String>();
				Collections.addAll(code, ids);
				codeWords.add(code);
				return null;
				
			}
			
			
			
			
			
		}
		else
		{

			if(sinkedMessages.contains(m.getId()))
				return DENIED_OLD;
					
			int result = super.checkReceiving(m);
			
			if (result == RCV_OK)
				if (FadSink.insert(m))
					return result;
				else
					return DENIED_OLD;
			return result;
		}
		
	}
	
	public static synchronized boolean insert(Message m){
		if (sinkedMessages.contains(m.getId()))
			return false;
		sinkedMessages.add(m.getId());	
		return true;
	}
	
	public Set<String> getSinkedMessages() {
		return sinkedMessages;
	}
	
	public static void reset() {
		sinkedMessages.clear();
	}
	
	public String hello(){
		return "FadSink";
	}
	
	@Override
	public MessageRouter replicate() {
		return new FadSink(this);
	}

}



