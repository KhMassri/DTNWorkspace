/**
 * 
 */
package routing;




import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

import movement.MovementModel;

import core.Connection;
import core.DTNHost;
import core.DTNSim;
import core.Message;
import core.Settings;

/**
 * @author khalil
 * 
 */
public class SinkRouter extends ActiveRouter {

	private  Set<String> sinkedMessages=new HashSet<String>();
	private  List<Set<String>> codeWords= new ArrayList<Set<String>>();
	int c = 0;



	/**
	 * @param s
	 */
	public SinkRouter(Settings s) {
		super(s);
	}

	protected SinkRouter(SinkRouter r) {
		super(r);
	}

	

	public void changedConnection(Connection con) {
		return;
	}


	@Override
	public void update() {
		super.update();
		
		if (isTransferring() || !canStartTransfer()) {
			return; // transferring, don't try other connections yet

		}	
	}

	public Message messageTransferred(String id, DTNHost from){
		

		String[] ids = id.split("&");
		if(ids.length>1)
		{  //System.out.println(ids[0]+"  "+ids[1]+" "+sinkedMessages.contains(ids[0])+" "+sinkedMessages.contains(ids[1]));
		
			if(sinkedMessages.contains(ids[0]) && !sinkedMessages.contains(ids[1]))
			{
				Message m = this.removeFromIncomingBuffer(id, from);
				m.setID(ids[1]);
				this.putToIncomingBuffer(m, from);
				m = super.messageTransferred(ids[1], from);
				sinkedMessages.add(ids[1]);
				return m;

			}
			else if(sinkedMessages.contains(ids[1]) && !sinkedMessages.contains(ids[0]))
			{
				Message m = this.removeFromIncomingBuffer(id, from);
				m.setID(ids[0]);
				this.putToIncomingBuffer(m, from);
				m = super.messageTransferred(ids[0], from);
				sinkedMessages.add(ids[0]);
				return m;

			

			}

			else if(!sinkedMessages.contains(ids[1]) && !sinkedMessages.contains(ids[0]))
			{
				Set<String> code = new HashSet<String>();
				Collections.addAll(code, ids);
				codeWords.add(code);

				return null;

			}
			else
				return null;
			


		}
		else
		{

			String id2 = null;
			
			for(Set<String> s:codeWords)
				if(s.contains(id))
				{
					id2 = (s.toArray()[0].equals(id))?((String) s.toArray()[1]):((String) s.toArray()[0]);
					codeWords.remove(s);
					
					break;
				}
				
			Message m = super.messageTransferred(id, from);
			sinkedMessages.add(m.getId());
			
			if(id2 != null)
			{
				m.setID(id2);
				this.putToIncomingBuffer(m, from);
				m = super.messageTransferred(id2, from);
				sinkedMessages.add(id2);
				System.out.print(c++);
				//System.out.println(codeWords.size());
			}
			
			
			return m;	
		}
	}

	protected int checkReceiving(Message m) {
		String[] ids = m.getId().split("&");

		/*two coded messages*/
		if(ids.length>1)
		{
			if(sinkedMessages.contains(ids[0]) && sinkedMessages.contains(ids[1]))
				return DENIED_OLD;
					
			
			else if(!sinkedMessages.contains(ids[0]) && !sinkedMessages.contains(ids[1]))
			{
				Set<String> code = new HashSet<String>();
				Collections.addAll(code, ids);
				for(Set<String> c:codeWords)
					if(code.equals(c))
						return DENIED_OLD;
				
				return super.checkReceiving(m);

			}
			
			else
				return super.checkReceiving(m);


		}
		
		/* not coded message*/
		else
		{

			if(sinkedMessages.contains(m.getId()))
				return DENIED_OLD;

			return super.checkReceiving(m);
		}

	}

	

	public Set<String> getSinkedMessages() {
		return sinkedMessages;
	}

	

	public String hello(){
		return "SinkRouter";
	}

	@Override
	public MessageRouter replicate() {
		return new SinkRouter(this);
	}

}



